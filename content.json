{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Aria2","text":"Aria2是一款开源下载工具，可简化不同设备和服务器之间的下载过程，支持磁力链接、BT种子、http等类型的文件下载，具有优秀性能及较低的资源占用，架构轻巧。 Aria2 upported protocols HTTP(S) FTP SFTP BitTorrent(BT) Metalink 启动设置设置环境变量 1.将aria2c.exe放置在自定义文件夹。 2.将&lt;自定义文件路径&gt;添加至环境变量 PATH即可。 3.终端中输入aria2c即可（可自定义该执行文件名称）。 Start.vbs12345CreateObject(&quot;WScript.Shell&quot;).Run &quot;aria2c.exe --conf-path=D:\\Applications\\Aria2\\aria2.conf&quot;,0'aria2c.exe为环境变量下的aria2c.exe文件''若没有定义PATH，需要在同级目录下''--conf-path=D:\\Applications\\Aria2\\aria2.conf为配置文件路径''可生成快捷f' Start.bat(同vbs)12@echo off &amp; title Aria2aria2c.exe --conf-path=aria2.conf Stop.bat123@echo off &amp; title Aria2 StopTaskkill /F /IM aria2c.exepause &gt; nul Restart.bat12Taskkill /F /IM aria2c.exestart Start.vbs Boot.bat1234567@echo off &amp; title Aria2 开机启动echo 1.将 Aria2 设为开机启动echo 2.取消 Aria2 开机启动set /p aria2= 请输入对应的序号：IF %aria2% EQU 1 (REG ADD HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\ /v Aria2 /t REG_SZ /d %cd%\\Start.vbs /f)IF %aria2% EQU 2 (REG DELETE HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\ /v Aria2 /f)pause &gt; nul 新建文件 Aria2.log：日志文件 aria2.session：下载历史文件 aria2.conf：配置文件 UI Aria2 Web Aria2Ng webui-aria2 yaaw aria2.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=E:\\Downloads# 日志文件log=E:\\APP\\Aria2\\aria2.log# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16Mdisk-cache=16M# 断点续传continue=true# 客户端伪装user-agent=netdisk;5.2.6;PC;PC-Windows;6.2.9200;WindowsBaiduYunGuanJiareferer=http://pan.baidu.com/disk/home## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5#max-concurrent-downloads=5# 同一服务器连接数, 添加时可指定, 默认:1,最大为16max-connection-per-server=6# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5#split=5# 整体下载速度限制, 运行时可修改, 默认:0#max-overall-download-limit=0# 单个任务下载速度限制, 默认:0#max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0#max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0#max-upload-limit=0# 禁用IPv6, 默认:false#disable-ipv6=true# 连接超时时间, 默认:60#timeout=60# 最大重试次数, 设置为0表示不限制重试次数, 默认:5#max-tries=5# 设置重试等待的秒数, 默认:0#retry-wait=0# 后台运行daemon=true## 进度保存相关 ### 从会话文件中读取下载任务input-file=E:\\APP\\Aria2\\aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=E:\\APP\\Aria2\\aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=&lt;TOKEN&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,启用加密后 RPC 服务需要使用 https 或者 wss 协议连接#rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥#rpc-certificate=/path/to/certificate.pem# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件#rpc-private-key=/path/to/certificate.key## BT/PT下载相关 ### 最小做种时间, 单位:分# seed-time = 60# 分离做种任务bt-detach-seed-only=true# 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=true# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:falsebt-enable-lpd=true# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=true# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要## 设置 peer id 前缀peer-id-prefix=-TR2770-user-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false, 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true# Trackersbt-tracker=udp://tracker.opentrackr.org:1337/announce,udp://tracker.leechers-paradise.org:6969/announce,udp://p4p.arenabg.com:1337/announce,udp://9.rarbg.to:2710/announce,udp://9.rarbg.me:2710/announce,udp://exodus.desync.com:6969/announce,udp://tracker.sbsub.com:2710/announce,udp://retracker.lanta-net.ru:2710/announce,udp://open.stealth.si:80/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.cyberia.is:6969/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.moeking.me:6969/announce,udp://tracker3.itzmx.com:6961/announce,udp://ipv4.tracker.harry.lu:80/announce,udp://bt2.archive.org:6969/announce,udp://bt1.archive.org:6969/announce,http://tracker1.itzmx.com:8080/announce,udp://valakas.rollo.dnsabr.com:2710/announce,udp://tracker.zerobytes.xyz:1337/announcebt-tracker=udp://tracker.coppersurfer.tk:6969/announce,udp://tracker.leechers-paradise.org:6969/announce,udp://tracker.opentrackr.org:1337/announce,udp://p4p.arenabg.com:1337/announce,udp://9.rarbg.to:2710/announce,udp://9.rarbg.me:2710/announce,udp://tracker.openbittorrent.com:80/announce,udp://exodus.desync.com:6969/announce,udp://tracker.tiny-vps.com:6969/announce,udp://retracker.lanta-net.ru:2710/announce,udp://open.stealth.si:80/announce,udp://tracker.moeking.me:6969/announce,udp://denis.stalker.upeer.me:6969/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.cyberia.is:6969/announce,udp://open.demonii.si:1337/announce,udp://ipv4.tracker.harry.lu:80/announce,udp://explodie.org:6969/announce,udp://xxxtor.com:2710/announce,udp://valakas.rollo.dnsabr.com:2710/announce 命令行Aria2 Documentation 12#aria2c [&lt;OPTIONS&gt;] [&lt;URI&gt;|&lt;MAGNET&gt;|&lt;TORRENT_FILE&gt;|&lt;METALINK_FILE&gt;] ...aria2c https://dl101.zlibcdn.com/dtoken/c8bc6a947d196ee591a12c763f135b9faria2c https://w.wallhaven.cc/full/3z/wallhaven-3z32j3.jpg Example Download a file 1$ aria2c &quot;http://host/file.zip&quot; To stop a download, press Ctrl-C. You can resume the transfer by running aria2c with the same argument in the same directory. Download a file from two different HTTP servers 1$ aria2c &quot;http://host/file.zip&quot; &quot;http://mirror/file.zip&quot; Download a file from one host using multiple connections 1$ aria2c -x2 -k1M &quot;http://host/file.zip&quot; Basic Options The directory to store the downloaded file. 1-d, --dir=&lt;DIR&gt; 1aria2c -d C:\\Users\\29921\\Desktop https://w.wallhaven.cc/full/rd/wallhaven-rddgwm.jpg Downloads the URIs listed in FILE. 1-i, --input-file=&lt;FILE&gt; 1C:\\Users\\29921\\Desktop&gt;aria2c -i urls.txt 12345#urls.txthttps://w.wallhaven.cc/full/8o/wallhaven-8ok7vk.jpghttps://w.wallhaven.cc/full/g7/wallhaven-g75r7d.jpghttps://w.wallhaven.cc/full/8o/wallhaven-8oev1j.jpghttps://w.wallhaven.cc/full/j3/wallhaven-j3wqwm.jpg You can specify multiple sources for a single entity by putting multiple URIs on a single line separated by the TAB character. Additionally, options can be specified after each URI line. Option lines must start with one or more white space characters (SPACE or TAB) and must only contain one option per line. Input files can use gzip compression. The file name of the log file. 1-l, --log=&lt;LOG&gt; If - is specified, log is written to stdout. If empty string(&quot; &quot;) is specified, or this option is omitted, no log is written to disk at all. 1aria2c -l aria2.log https://w.wallhaven.cc/full/rd/wallhaven-rdqxmm.jpg Set the maximum number of parallel downloads for every queue item.(Default:5) 1-j, --max-concurrent-downloads=&lt;N&gt; 12aria2c -i urls.txt -j1aria2c -i urls.txt -j5 1234567#urls.txthttps://w.wallhaven.cc/full/p8/wallhaven-p86z2j.jpghttps://w.wallhaven.cc/full/v9/wallhaven-v9py65.jpghttps://w.wallhaven.cc/full/vg/wallhaven-vgyozm.jpghttps://w.wallhaven.cc/full/j5/wallhaven-j55e7y.jpghttps://w.wallhaven.cc/full/83/wallhaven-83xjgo.jpghttps://w.wallhaven.cc/full/g8/wallhaven-g8yx37.jpg -V, –check-integrity [true|false] Default: false Check file integrity by validating piece hashes or a hash of entire file. If piece hashes are provided, this option can detect damaged portions of a file and re-download them. If a hash of entire file is provided, hash check is only done when file has been already download. -c, –continue [true|false] Default: true Continue downloading a partially downloaded file. Use this option to resume a download started by a web browser or another program which downloads files sequentially from the beginning. Currently this option is only applicable to HTTP(S)/FTP downloads 1aria2c -cfalse https://dldir1.qq.com/music/clntupate/QQMusicSetup.exe","link":"/2021/07/31/Aria2/"},{"title":"Powershell初学","text":"Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。 PowerShellscoop download 安装VNote(MakeDown笔记软件) 1scoop install vnote 安装Youtube-dl/ffmpeg 12scoop install youtube-dlscoop search ffmpeg 安装colortool 123scoop install colortoolcolortool -scolortool OneHalfDark.itermcolors 安装7zip/git 1scoop install 7zip/git 安装touch/vim/grep/sudo 1scoop install touch/vim/grep/sudo 安装aria2 1scoop install aria2 安装figlet 1scoop install figlet telegram 1scoop install telegram Tor-Brower 1scoop uninstall tor-browser Cmdlet(Verb-Noun)1cmd/ise 12345$PsVersionTable$ConfirmPreference❯ $profileC:\\Users\\29921\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 1help/Get-Help/man(空格/Ctrl+C) Help Get-EventLogHelp Get-EventLog -fullHelp Get-EventLog -exampleHelp Get-EventLog -online 1gci/dir/ls/Get-ChildItem dir *.lnkls -path *.lnk 1cd/sl/chdir/Set-Location Set-Location -Path HKCU: 1cls/clear /Clear-Host 1gal/Get-Alias Get-Alias niget-alias -Definition get-process/get-alias -Definition “get-process” 1move/mi/mv/ Move-Item move -Path ./yz.c -Destination ./yz(Tab键补齐) 1help ps 12(get-command **get-eventlog** | select -ExpandProperty parameters).**computername**.aliases(查看*Get-EventLog*的*get-process*参数别名)get-command -verb import/ get-command -verb export 1show-command(copy) show-command move-item 1Get-PsProvider 1Get-PsDrive 1New-item/ni/mkdir new-item testfolder -type directorymkdir testfolder 1Get-Process/gps/ps 1Get-Service 1Get-Eventlog 12Get-Contentget-content env:psmodulepath 1Get-Psprovider 1Get-Member/gm Pipeline1ls | more 1234Get-Process(运行进程信息) | Export-CSV process.csvImport-CSV process.csvnotepad process.csv./process.csv(Excel打开) 12get-process | export-clixml process.xmlimport-clixml process.xml 12get-process | EXport-clixml standard.xmldiff -Reference (Import-CliXML standard.xml) -Difference (Get-Process) -Property name 12Dir &gt; DirectoryList.txtDir | Out-File DirectoryList.txt 12dirdir | out-default | out-host(底层实现) 12&quot;hello world&quot; | out-default | out-host&quot;hello world&quot; | out-host 12Get-Service | Convertto-htmlGet-Service | Convertto-html | out-file services.html 1234Get-process | Stop-Process Get-process | Stop-Process -confirmGet-process | Stop-Process -whatifget-process -name notepad | stop-process Module12345678910Get-Module(当前会话下的模块)/Get-Module -ListAvailable(当前PC上所有的模块)❯ Get-ModuleModuleType Version Name ExportedCommands---------- ------- ---- ----------------Manifest 3.1.0.0 Microsoft.PowerShell.Management {Add-Computer, Add-Content, Checkpoint-Computer, Clear-Content...}Manifest 3.1.0.0 Microsoft.PowerShell.Utility {Add-Member, Add-Type, Clear-Variable, Compare-Object...}Script 3.106.2 oh-my-posh {Export-PoshTheme, Get-PoshInfoForV2Users, Get-PoshThemes, Set-PoshPrompt...}Script 0.7.3 posh-git {Add-PoshGitToProfile, Add-SshKey, Enable-GitColors, Expand-GitCommand...}Script 2.0.0 PSReadline {Get-PSReadLineKeyHandler, Get-PSReadLineOption, Remove-PSReadLineKeyHandler, Set-PSReadLineKe... 123Remove-Module/Remove-PSSnapin#使用Remove-Module -Name Functions2 只是移除当前会话的模块#并且Import-Module -Name Functions2与 Remove-Module -Name Functions2是相对应的，只有先import才能remove，不然会提示找不到模块 1#删除模块（使用get-module -ListAvailable找到该模块对应文件夹，删除即可） 1Import-Module 123import-Module DnsClientget-command -Module DnsClientClear-DnsClientCache -Verbose 123456789101112131415161718//修改配置脚本❯ $profileC:\\Users\\29921\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1&gt; cd C:\\Users\\29921\\Documents\\WindowsPowerShell\\❯ get-content Microsoft.PowerShell_profile.ps1Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme Paradoxnotepad Microsoft.PowerShell_profile.ps1&lt;Microsoft.PowerShell_profile.ps1&gt;Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme Paradoxcls PowershellGet(PowerShell Gallery) 1234Register-PSRepositoryFind-Module *vpn*Install-ModuleUpdate-Module oh-my-posh 12sudo install-module AzureADsudo Install-Script -Name New-ADUserName 12345678910111213141516#安装Pswritecolor模块[URL](https://www.powershellgallery.com/packages/PSWriteColor/0.87.2)find-Module Pswritecolorsudo Install-Module Pswritecolorimport-module -name Pswritecolor&gt; get-command -Module PswritecolorCommandType Name Version----------- ---- -------Alias Write-Colour 0.87.2Function Write-Color 0.87.2HELP Write-Colorget-help Write-Color -examplesWrite-Color -Text &quot;Red &quot;, &quot;Green &quot;, &quot;Yellow &quot; -Color Red,Green,Yellow 12345#安装 Get-ChildItemColor模块 ：为 PowerShell 的输出添加颜色sudo Install-Module -AllowClobber Get-ChildItemColorcd C:\\Users\\29921\\Documents\\WindowsPowerShell\\notepad Microsoft.PowerShell_profile.ps1新增Import-Module Get-ChildItemColor 12345678910111213141516171819202122232425#安装Terminal-Icons模块（ adds file and folder icons when displaying items in the terminal）#与Get-ChildItemColor模块冲突，不要同时导入#[Nerd Fonts](https://github.com/ryanoasis/nerd-fonts)1.下载并安装此版本的Literation Mono Nerd字体，已将其特别固定为在Windows上识别为等宽字体：https://github.com/haasosaurus/nerd-fonts/blob/regen-mono-font-fix/patched-fonts/LiberationMono/complete/Literation%20Mono%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf2.修改注册表以将其添加到终端应用程序的字体列表（cmd，powershell等）中：$key = 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont'Set-ItemProperty -Path $key -Name '000' -Value 'LiberationMono NF'3.打开PowerShell，右键单击标题栏&gt;默认值&gt;字体&gt;从列表中选择新字体。4.安装Terminal-Icons模块：sudo Install-Module Terminal-Icons5.修改Windows terminal settings.json&quot;fontFace&quot; : &quot;LiterationMono NF&quot;,6.配置脚本notepad C:\\Users\\29921\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1Import-Module posh-gitImport-Module oh-my-poshImport-Module Terminal-IconsSet-PoshPrompt -Theme Paradox 1234567891011#安装PScolors模块（与oh-my-posh Terminal-Icons均冲突）1.Windows 10用户：Install-Module PSColors -Scope CurrentUser -AllowClobber注意：AllowClobber只有在周年更新之后才需要否则，如果您安装了PsGet：sudo Install-Module PSColors2.配置脚本notepad C:\\Users\\29921\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1Import-Module PSColors Objects1Get-Process | Convertto-HTMl | out-file process.html # Convertto-HTMl不会过滤列，可以查看整个表 1Get-process | gm 12Get-process | Sort-Object -Property vmGet-process | Sort-Object -Property vm,id -Descending 123456get-process | ConvertTo-HTML | out-File test.htmlget-process |Select-object -property Name,ID,VM,PM | ConvertTo-HTML | out-File test.htmlget-process |Select Name,ID,VM,PM```shellget-process | select Name,ID,VM,PM -First 4get-process | select Name,ID,VM,PM -Last 4 1234567❯ get-process |&gt;&gt; Sort-Object vm -Descending |&gt;&gt; out-file test.txt&gt; get-process |&gt;&gt; Sort-Object vm -Descending |&gt;&gt; Select-Object Name,ID,VM 1234567891011121314151617181920212223242526272829303132Get-Process | sort vm -Descending | GM❯ Get-Process | sort vm -Descending | select Name,ID,VM |GM TypeName:Selected.System.Diagnostics.ProcessName MemberType Definition---- ---------- ----------Equals Method bool Equals(System.Object obj)GetHashCode Method int GetHashCode()GetType Method type GetType()ToString Method string ToString()Id NoteProperty int Id=11340Name NoteProperty string Name=msedgeVM NoteProperty long VM=2341582123008❯ Get-process | Gm | GM TypeName:Microsoft.PowerShell.Commands.MemberDefinitionName MemberType Definition---- ---------- ----------Equals Method bool Equals(System.Object obj)GetHashCode Method int GetHashCode()GetType Method type GetType()ToString Method string ToString()Definition Property string Definition {get;}MemberType Property System.Management.Automation.PSMemberTypes MemberType {get;}Name Property string Name {get;}TypeName Property string TypeName {get;} 12345678910❯ get-content test.txtC:\\Users\\29921\\desktopC:\\Users\\29921\\img❯ get-content test.txt | GM TypeName:System.String get-content ./test.txt | ls 123456789101112❯ Get-content ./test.txtMySQL80edgeupdate❯ Get-content ./test.txt | Get-ServiceStatus Name DisplayName------ ---- -----------Running MySQL80 MySQL80Stopped edgeupdate Microsoft Edge 更新 服务 (edgeupdate) 12345678910111213❯ get-content .\\test.csvHandles, ProcessName276,notepad1034,QQMusic❯ import-csv .\\test.csvHandles ProcessName------- -----------276 notepad1034 QQMusicimport-csv .\\test.csv | stop-process","link":"/2021/08/15/PowerShell%E5%85%A5%E9%97%A8/"},{"title":"Blog With Hexo","text":"Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，配合Github即可搭建初级个人博客。 Hexo简介 ​ Hexo中文官网 中文官方文档 Themes Plugins 准备工作 Node.js Git GitHub 安装Hexo123456789101. npm install hexo-cli -g2. hexo init blogName3. cd blogName4. npm install5. hexo server6. npm install hexo-deployer-git --save #Git部署插件7. hexo new page tags8. hexo new page categories #生成 categories 分类页 常用命令 12345hexo n &quot;BlogName&quot;/hexo new &quot;BlogName&quot; #新建文章 *.mdhexo g/hexo generate hexo s/hexo server #启动服务器hexo d/hexo deploy #部署到服务器hexo clean #清理缓存 Front-matter 设置标签和分类等参数值 layout 应用布局样式 title 标题 date 建立日期 updated 更新日期 comments 开启文章评论 truetags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 excerpt 指定文章摘要 categories 设置文章分类 tags 设置文章标签 link 设置标题链接 photos 设置页面插图 特有Front-Matter属性 top_image 页面顶部图 toc 是否启用目录 toc_min_depth 生成目录最小深度 toc_max_depth 生成目录最大深度 quicklink 是否预取链接 math 是否解析数学公式 sidebar 是否显示侧边栏 reward 是否启用打赏功能 copyright是否启用版权信息 top是否置顶文章 no-emoji 是否解析 emoji 代码 文章摘要：摘要内容后添 &lt;!-- more --&gt; &lt;!-- more --&gt; 之前、文档配置参数之后内容会渲染为站点中的文章摘要，将是正文中最前面的内容。 Github repo 创建 username.github.io仓库 配置本地Git配置 1234git config --global user.name &quot;&lt;Github UseName&gt;&quot;git config --global user.email &quot;&lt;GitHub Email&gt;&quot;#生成吗密钥ssh-keygen -t rsa -C &quot;&lt;GitHub Email&gt;&quot; 复制用户.ssh文件夹中的id_rsa.pub公钥文件 add ssh key 配置_config.yml，关联Hexo与GitHub 配置是否成功 1ssh git@github.com Hexo Tree12345678910111213141516171819.├── _config.yml├── .github├── public #部署到Github repo的内容(生成的静态网页以及相关资源)├── package.json #应用程序信息及需安装模块信息├── node_modules ├── scaffolds #模板文件夹├── source #用户资源| ├── tags| ├── categories| └── _posts|└── themes #主题配置文件 将Github仓库中主题文件放置其中，其中的_config.yml可进行主题配置 ├── stun（主题名 配置可参考该主题的官方文档） ├── languages #语言配置文件 ├── layout #主题布局样式文件 ├── scripts #主题所需Js文件 ├── source #主题资源文件 ├── _config.yml #主题配置 stun主题 hexo-theme-stun文档 上传脚本12345#Windows ps1/bat Linux shcd &lt;hexo root dir&gt;hexo cleanhexo ghexo d","link":"/2021/08/13/Blog-With-Hexo/"},{"title":"JavaScript基础","text":"JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型编程语言。作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。 JavaScript [toc] (1).初识JavaScript​ JavaScript教程 JavaScript ​ 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/style.css&quot;&gt; &lt;title&gt;JavaScript Crash Course&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;JavaScript Crash Course&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; alert(&quot;Hello JavaScript World&quot;);&lt;/script&gt;&lt;script src=&quot;scripts/main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;scripts/test.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 12345678910111213141516body { text-align: center; font-family: Arial, Helvetica, sans-serif; font-size: 30px;}.header { background-color: #f4f4f4; border-bottom: #ccc 3px soild; padding: 20px;}.container { width:200px; margin: 30px auto;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091var userName=&quot;Joker&quot;;var userAge = 20;if(userName==&quot;Joker&quot;&amp;&amp;userAge&lt;=18){ console.log(&quot;This is Joker&quot;);}else{ console.log(&quot;No Joker&quot;);}if(userAge&lt;=18){ console.log(&quot;This Child&quot;);}else if(userAge&gt;18&amp;&amp;userAge&lt;=40){ console.log(&quot;This man&quot;);}else{ console.log(&quot;Stranger&quot;);}while(userAge&lt;=25){ userAge++; console.log(userAge);}do{ userAge--; console.log(userAge);}while(userAge&gt;=20)for(let i=0;i&lt;6;i++){ console.log(i);}var allow = userAge&gt;=18 ? &quot;Yes&quot; : &quot;No&quot;;console.log(allow);switch(userName){ case &quot;Joker&quot;: console.log(&quot;This is Joker&quot;); break; case &quot;Jack&quot;: console.log(&quot;This is Jack&quot;); break; default: console.log(&quot;This is Strager&quot;);}var obj =new Object();var obj2 = {};obj = { userName:&quot;Poker&quot;, userAge:&quot;22&quot;, contact:{ phone:&quot;123333&quot;, Telgram:&quot;@Poker&quot; }}obj.contact.weChat=&quot;Po&quot;;console.log(obj);console.log(obj.userName);console.log(obj[&quot;contact&quot;][&quot;phone&quot;]);obj.userAge = &quot;12&quot;;console.log(obj.userAge)var ar = new Array();var br = [];ar[0]=&quot;dog&quot;;ar[1]=&quot;cat&quot;;ar.push(&quot;Duck&quot;);ar.reverse();ar.pop();ar.shift();ar.unshift(&quot;Fog&quot;)console.log(ar);br=[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;];console.log(br);for(let i=0;i&lt;br.length;i++){ console.log(br[i]);}for(let i in br){ console.log(br[i]);} 123456789101112131415161718192021222324252627282930313233343536alert(Math.PI);console.log(&quot;Hello&quot;.length);console.log(&quot;Hello&quot;.charAt(0));console.log(&quot;Hello World&quot;.replace(&quot;World&quot;,&quot;JavaScript&quot;));console.log(&quot;hello world&quot;.toUpperCase());var userName = &quot;MrLing&quot;;console.log(userName);let a=1;console.log(a);userName = &quot;MrZero&quot;;a=a+1;console.log(a);console.log(userName);const PI = 3.1415;console.log(PI);var x =5;x+=5;x-=4;x++;console.log(x+5);x--;console.log(x);var test;test = &quot;1&quot;+&quot;1&quot;;console.log(test);test =&quot;5&quot;+3+4 //&quot;5&quot;+&quot;3&quot;+&quot;4&quot;;console.log(test);test =5+3+&quot;4&quot;; //&quot;8&quot;+&quot;4&quot;;console.log(test);console.log(123==&quot;123&quot;); //trueconsole.log(123===&quot;123&quot;); //false 12345678910111213141516171819202122232425262728var a =0;function add(x){ a+=x;}add(12);console.log(a);function addNum(){ let sum=0; for(let i =0,j=arguments.length;i&lt;j;i++){ sum+=arguments[i]; } return sum;}console.log(addNum(1,2,3,4,5));//闭包function addMaker(a){ return function(b){ return a+b; };}var x = addMaker(56);var sum =x(4);console.log(sum); 0.术语 可扩展超文本标记语言（XHTML，Extensible HyperText Markup Language） 万维网联盟（W3C，World Wide Web Consortium） ​ 1.DOM 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=&quot;title&quot;&gt;Hello&lt;/h1&gt; &lt;button&gt;Click me&lt;/button&gt; &lt;ul id=&quot;sp-list&quot;&gt; &lt;li class=&quot;list&quot;&gt;First&lt;/li&gt; &lt;li class=&quot;list&quot;&gt;Second&lt;/li&gt; &lt;li class=&quot;list&quot;&gt;Third&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; ​ HTML DOM Style 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;button&gt;Click me&lt;/button&gt; &lt;ul id=&quot;sp-list&quot; class=&quot;list&quot;&gt; &lt;li class=&quot;list&quot;&gt;First&lt;/li&gt; &lt;li class=&quot;list&quot;&gt;Second&lt;/li&gt; &lt;li class=&quot;list&quot;&gt;Third&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 1234567li.list { background-color: aquamarine;}.title{ color: red;} ​ (2).JavaScript程序设计1.初解JavaScript​ ​ ECMAScript (核心)+BOM（文档对象模型:网页内容交互）+DOM（浏览器对象模型:浏览器交互） ECMAScript，即 ECMA-262 定义的语言。ECMAScript,只是对实现这个规范描述的所有方面的一门语言的称呼。JavaScript 实现了 ECMAScript，而 Adobe ActionScript 同样也实现了 ECMAScript。 1.DOM(Document Object Model) 应用编程接口（API） 用于在 HTML 中使用扩展的 XML 将整个页面抽象为一组分层节点 创建表示文档的树控制网页的内容和结构 2.BOM(Browser Object Model) 用于支持访问和操作浏览器的窗口 3.HTML 中的JavaScript JavaScript插入 HTML : 使用方法 ==网页嵌入 JavaScript代码(推荐)== 1&lt;script&gt; function sayHi(){ console.log(&quot;Hello world&quot;); }&lt;/script&gt; 1.包含在内的代码会被从上到下解释 2.在元素中的代码计算完成前，页面其余内容不会被加载或显示 3.代码中不能出现字符串，需要转义字符“\\” 1console.log(&quot;&lt;\\/script&gt;&quot;); 导入外部 JavaScript文件 1.使用src属性,可以是完整的 URL，指向包含 JavaScript 代码的文件(浏览器解析该资源时，会向 src 属性指定路径发送一个 GET 请求，以取得相应资源) 1&lt;script src=&quot;http://www.somewhere.com/afile.js&quot;&gt;&lt;/script&gt; 1&lt;script src=&quot;scripts/example.js&quot;&gt;&lt;/script&gt; 2.解释外部 JavaScript 文件时，页面也会阻塞（阻塞时间包含下载文件的时间） 3.使用 src 属性的&lt;script&gt;元素不应在标签中包含 JavaScript 代码。浏览器只会下载并执行脚本文件，从而忽略行内代码 标签位置 现代 Web 应用程序通常将所有 JavaScript 引用放在**元素中的页面内容后面**(在处理 JavaScript 代码之前渲染页面,浏览器显示空白页面的时间短了) 推迟执行脚本 HTML 4.01为&lt;script&gt;元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。（defer必须用于导入外部 JS文件的script标签中） 1&lt;script defer src=&quot;example1.js&quot;&gt;&lt;/script&gt; 1&lt;body&gt; &lt;script defer src=&quot;scripts/example.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function sayHi(){ console.log(&quot;Hello world&quot;); } sayHi(); console.log(&quot;&lt;\\/script&gt;&quot;); &lt;/script&gt; &lt;/body&gt; 1console.log(&quot;Test JavaScript defer&quot;); **&lt;noscript&gt;元素 ** 1&lt;noscript&gt;元素可包含任何可出现在&lt;body&gt;中的 HTML 元素，&lt;script&gt;除外。在下列情况下，浏览器将显示包含在&lt;noscript&gt;中的内容：1.浏览器不支持脚本；2.浏览器对脚本的支持被关闭。任何一个条件被满足，包含在&lt;noscript&gt;中的内容就会被渲染。否则，浏览器不会渲染&lt;noscript&gt;中的内容 小结 2.JavaScript语言基础1.语法（ES6）1.区分大小写 ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写. 2.标识符 标识符，即变量、函数、属性或函数参数的名称 第一个字符必须是一个字母、下划线（_）或美元符号（$） ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写 3.注释 单行注释 1//单行注释 块注释 1/* 多行注释 */ 4.严格模式 ECMAScript 5 增加了严格模式（strict mode） 严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误 脚本启用严格模式: 1&quot;use strict&quot;; //脚本开头（预处理指令） 指定函数在严格模式下执行: 1function doSomething() { &quot;use strict&quot;; // 函数体 } 所有现代浏览器都支持严格模式 5.语句 ECMAScript 中的语句以分号结尾（推荐），省略分号将由解析器确定语句在哪里结尾。 始终在控制语句中使用代码块，即使只有一条语句要执行。 1// 推荐if (test) { console.log(test); } 6.关键字 ​ 7.变量 变量可以保存任何类型的数据(保存任意值的命名占位符) 3 个关键字声明变量：**var(各个版本)、const**(ES6及以上) 和 let((ES6及以上) 1.var 变量保存任何类型的值。不初始化的情况下，变量保存一个特殊值undefined 1var variableName; 初始化变量只是简单赋值,之后不仅可改变保存的值，也可以改变值的类型 1var test = &quot;JustforTest&quot;;test=100; //合法但不推荐 var 声明作用域 var定义的变量会成为包含它的函数的局部变量 在函数内定义变量时省略 var 操作符，可创建一个全局变量（不推荐） 1function test(){ t = &quot;JustforTest&quot;;}test(); //需要调用函数test()才会定义该全局变量，并在函数外部访问console.log(t); 定义或初始化多个变量可在一条语句中用逗号分隔每个变量 不同数据类型初始化的变量可以用一条语句来声明 严格模式下不能定义名为 eval 和arguments的变量，否则会导致语法错误 1var message=&quot;Hello&quot;,found=&quot;false&quot;,age=29;var message = &quot;hi&quot;, //插入换行和空格缩进并非必需，但有利于阅读 found = false, age = 29; var 声明提升 使用关键字声明的变量会自动提升到函数作用域顶部（所谓提升(hoist)，就是把所有变量声明都拉到函数作用域的顶部） 1function foo() { console.log(age); var age = 26; } foo(); //undefined //ECMAScript运行时将该代码等价于：function foo() { var age; console.log(age); age = 26; } foo(); //undefined //可使用var声明同一个变量function foo() { var age = 16; var age = 26; var age = 36; console.log(age); } foo(); //36 //ECMAScript运行时将该代码等价于：function foo() { var age; age = 16; age = 26; age = 36; console.log(age); } foo(); //36 2.let let声明的范围是块作用域， 而 var声明的范围是函数作用域 1if(true){ var test1 = &quot;varTest&quot;; let test2 = &quot;letTest&quot;;}console.log(test1); //varTestconsole.log(test2); //报错:Uncaught ReferenceError: test2 is not defined//let定义的变量作用域仅限于该块内部，不能在if块外部被引用 块作用域是函数作用域的子集，因此适用于var的作用域限制同样适用于let let不允许同一个块作用域中出现冗余声明 1let age; let age; //Uncaught SyntaxError: Identifier 'age' has already been declared 嵌套使用相同的标识符不会报错(同一个块中没有重复声明) 1let age = 10;console.log(age);if(age==10){ let age =20; console.log(age);} 声明冗余报错不会因混用 let 和 var 而受影响 两个关键字指出的是变量在相关作用域如何存在 1var name; let name; //Uncaught SyntaxError: Identifier 'name' has already been declaredlet age; var age; let声明的变量不会在作用域中被提升(let声明之前的执行瞬间被称为**暂时性死区(temporal dead zone)，在此阶段引用任何后面才声明的变量都会抛出ReferenceError**) 1console.log(age); //Uncaught ReferenceError: Cannot access 'num' before initializationlet age = 26; 使用let 在全局作用域中声明的变量不会成为 window 对象的属性（var声明的变量则会） 1var userName =&quot;Matt&quot;;console.log(window.userName); //Mattlet userAge = 25;console.log(window.userAge); //undefined 使用**var声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为let 的作用域是块，所以不可能检查前面是否已经使用**let声明过同名变量，同时也就不可能在没有声明的情况下声明它。 1&lt;body&gt; &lt;script&gt; var name = 'Nicholas'; let age = 26; console.log(name); //Nicholas console.log(age); //26 &lt;/script&gt; &lt;script&gt; var name = 'Matt'; let age = 36; //Uncaught SyntaxError: Identifier 'age' has already been declared &lt;/script&gt; &lt;/body&gt; for循环中的**let**声明 1//for循环定义的迭代变量渗透到循环体外部for(var i=0;i&lt;5;++i){ console.log(i);}console.log(i); //5//let定义的迭代变量的作用域仅限于for循环块内部for(let i=0;i&lt;5;++i){ console.log(i); //0~4}console.log(i); //Uncaught ReferenceError: i is not defined//在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的i都是同一个变量，因而输出的都是同一个最终值for (var i = 0; i &lt; 5; ++i) { setTimeout(() =&gt; console.log(i), 0) //5、5、5、5、5} //在使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout引用的都是不同的变量实例，所以 console.log 输出的是循环执行过程中每个迭代变量的值。for (let i = 0; i &lt; 5; ++i) { setTimeout(() =&gt; console.log(i), 0) //0、1、2、3、4} //每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括for-in和for-of循环 1let num = 100 ;if(true){ console.log(num); //100}for(let i=0;i&lt;num/100+2;i++){ console.log(num); //100 100 100} 3.const const行为与let基本相同，区别是用它声明变量时必须同时初始化变量，且修改const声明的变量会导致运行时错误。 **const**不允许重复声明 **const**声明的作用域是块 const声明的限制只适用于它指向的变量的引用。如果**const变量引用的是一个对象,那么修改这个对象内部的属性并不违反const的限制**。 1const age;age=24; //Uncaught SyntaxError: Missing initializer in const declaratioconst age =26;age=24; //Uncaught TypeError: Assignment to constant variableconst age=24;const age=10; //Uncaught SyntaxError: Identifier 'age' has already been declareconst age=12;if(true){ const age=13;}console.log(age); //12const person = {}; person.name = 'Matt'; const不能来声明迭代变量(循环),可用**const**声明不会被修改的for循环变量 1for (const i = 0; i &lt; 10; ++i) {} //Uncaught TypeError: Assignment to constant variable.for (const key in {a: 1, b: 2}) { console.log(key); //a b} for (const value of [1,2,3,4,5]) { console.log(value); //1~5} 声明风格 8.数据类型​ JavaScript data types and data structures 6种简单数据类型（原始类型） Undefined BigInt (ECMAScript2020 新增) Boolean Number String Symbol （ES6新增） Structural Types Object Function Structural Root Primitive null 0. typeof typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数) (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof) 确定任意变量的数据类型 undefined 表示值未定义 boolean 表示值为布尔值 string 表示值为字符串 number 表示值为数值 object 表示值为对象或null function 表示值为函数 symbol 表示值为符号 bigint 表示值为BigInt 1let test = &quot;JustForTest&quot;;let num;const theBiggestInt = 9007199254740991n;function fun(){ console.log(&quot;Hello&quot;);}console.log(typeof test); //stringconsole.log(typeof(test)); //stringconsole.log(typeof 67); //numberconsole.log(typeof true); //booleanconsole.log(typeof num); //undefinedconsole.log(typeof fun); //functionconsole.log(typeof null); //object(null被认为是一个对空对象的引用)console.log(typeof Symbol()); //symbolconsole.log(typeof {a: 1}); //objectconsole.log(typeof theBiggestInt); //bigint 1. Undefined Undefined只有一个值，就是特殊值undefined。当使用var 或**let** 声明变量但没有初始化时，相当于给变量赋undefined值： 1let message;console.log(message == undefined); //true//等价于let message=undefined;console.log(message == undefined); ​ 默认情况下，任何未经初始化的变量都会取得undefined值 ​ 包含undefined值的变量跟未定义变量有很大区别 **输出一个未声明的变量会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用typeof**。 对未声明的变量调用typeof时，返回结果是 undefined 无论是声明还是未声明，typeof 返回的都是字符串undefined。所以建议在声明变量的同时进行初始化。这样当**typeof返回undefined**时，就知道是因为给定的变量尚未声明，而非声明了但未初始化。 1let message;console.log(message); //undefined//console.log(age); //Uncaught ReferenceError: age is not definedconsole.log(typeof message); //undefinedconsole.log(typeof age); //undefined undefined是一个假值，因此可以用更简洁的方式检测它，需要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。 1let message;if(message){ console.log(&quot;Tset1Run&quot;);}if(!message){ console.log(&quot;Test2Run&quot;); //Test2Run}if(age){ //Uncaught ReferenceError: age is not defined} 2. Null Null类型只有一个值，即特殊值null。逻辑上讲，null 值表示一个空对象指针，这也是给**typeof传一个null会返回object**的原因 定义将来要保存对象值的变量时，建议使用null来初始化。只要检查这个变量的值是不是**null就可知道该变量是否在后来被重新赋予了一个对象的引用** 1let test = null;console.log(typeof test); //objectif(test!=null){ console.log(&quot;test是一个对象的引用&quot;);} undefined值是由null值派生而来的，因此 ECMA-262 将它们定义为表面上相等 1console.log(undefined==null); //true 如果定义的变量在将来用于保存对象，就要将该变量初始化为 null (保持**null是空对象指针的语义，并与undefined**区分开来) null 是一个假值，因此可以用更简洁的方式检测它，需要明确自己想检测的就是**null**这个字面值，而不仅仅是假值。 1let car=null;let age;if(car){ console.log(&quot;Test1&quot;);}if(!car){ console.log(&quot;Test2&quot;); //Test2}if(age){ console.log(&quot;Test3&quot;);}if(!age){ console.log(&quot;Test4&quot;); //Test4} 3. BooleanBoolean（布尔值）类型有两个字面值：true 和 false。 这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0 1let found = true;let lost = false;console.log(true==1); //true 转换后比较console.log(false==0); //trueconsole.log(&quot;&quot;==0); //trueconsole.log(true===0); //false 可看出布尔值不同于数值 布尔值字面量 true 和 false是区分大小写的 : True 和 False（及其他大小混写形式）是有效的标识符，但不是布尔值 所有其他ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用**Boolean()**转型函数 1let message1=&quot;HelloWorld&quot;;let message2=&quot;&quot;;console.log(Boolean(message1)); //trueconsole.log(Boolean(message2)); //falseconsole.log(Boolean(1)); //trueconsole.log(Boolean(0)); //falseconsole.log(Boolean({phone:&quot;123456&quot;})); //trueconsole.log(Boolean(null)); //falseconsole.log(Boolean(undefined)); //false if 等流控制语句会自动执行其他类型值到布尔值的转换 1let num = 10;if(&quot;test&quot;){ console.log(&quot;JustForTest&quot;); //JustForTest}if(num){ console.log(&quot;JustForTest&quot;); //JustForTest} 4. NumberNumber类型使用IEEE 754格式表示整数和浮点值（在某些语言中叫**双精度值 **double） 数值字面量格式 十进制 1let num = 100; 八进制 第一个数字必须是零 0，然后是相应的八进制数字。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。 1let num1 = 070;let num2 = 080;let num3 = 09;console.log(num1); //56console.log(num2); //80console.log(num3); //9 ECMAScript2015或ES6中的八进制值通过**前缀 0o表示；严格模式下，前缀0会被视为语法错误，如果要表示八进制值，应该使用前缀 0o**。 十六进制 让数值前缀 0x（区分大小写），然后是十六进制数字（0~9 以 及 A~F）。十六进制数字中的字母大小写均可。 1let num1 = 0xA;let num2 = 0xB;let num3 = 0x1f;console.log(num1); //10console.log(num2); //11console.log(num3); //31 由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。 使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。 浮点值 定义浮点值时，数值中必须包含小数点，而且小数点后面至少有一个数字。 1let num1 = 0.1;let num2 = 1.1;let num3 = .1; //小数点前面不是必须有整数，但建议加上console.log(num1); //0.1console.log(num2); //1.1console.log(num3); //0.1 因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想把值转换为整数。 在小数点后面没有数字的情况下，数值就会变成整数。 如果数值本身就是整数，只是小数点后面跟着 0，那它也会被转换为整数。 1let num1 = 1.0;let num2 = 2.;console.log(num1); //1console.log(num2); //2 对于非常大或非常小的数值，浮点值可以用科学记数法表示。科学记数法表示一个乘以10的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大 写或小写的字母 e，再加上一个要乘的10 的多少次幂。 1let num1 = 3212e6;let num2 = 0.3212E6;let num3 = 3212e-6;console.log(num1); //3212000000console.log(num2); //321200console.log(num3); //0.003212 默认情况下，ECMAScript 会将小数点后至少包含 6个0的浮点值转换为科学记数法 浮点值的精确度最高可达17 位小数，但在算术计算中远不如整数精确 1let num1 = 0.2;let num2 = 0.1;console.log(num1+num2); //0.30000000000000004(并非0.3) 永远不要测试某个特定的浮点值。 1let num1 = 0.2;let num2 = 0.1;let num3 = 0.05;let num4 = 0.25;if(num1+num2==0.3){ console.log(&quot;test1&quot;);}if(num4+num3==0.3){ console.log(&quot;test2&quot;); //test2} 之所以存在这种舍入错误，是因为使用了IEEE 754数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题。 值的范围 由于内存的限制，ECMAScript并不支持表示这个世界上的所有数值 ECMAScript 可表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了JavaScript可表示的范围，那么这个数值会被自动转换为一个特殊的 **Infinity**（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示 Infinity没有可用于计算的数值表示形式，所以如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。 确定一个值是否为有限大（即介于 JavaScript 能表示的最小值和最大值之间），可使用 **isFinite()**函数 1console.log(Number.MIN_VALUE); //5e-324console.log(Number.MAX_VALUE); //1.7976931348623157e+308console.log(Number.MAX_VALUE*2) //Infinityconsole.log(-Number.MAX_VALUE) //-1.7976931348623157e+308console.log(-(Number.MAX_VALUE*2)) //-Infinityconsole.log(Number.NEGATIVE_INFINITY); //-Infinityconsole.log(Number.POSITIVE_INFINITY); //Infinity 这两个属性包含的值分别就是-Infinity 和 Infinityconsole.log(isFinite(Number.MIN_VALUE)); //trueconsole.log(isFinite(Number.MAX_VALUE)); //trueconsole.log(isFinite(Number.MAX_VALUE*2)); //falseconsole.log(isFinite(-(Number.MAX_VALUE*2)));//false NaN NaN,不是数值（Not a Number），表示本来要返回数值的操作失败（而不是抛出错误）。 用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0 或-0 相除会返回 NaN 1console.log(0/0); //NaNconsole.log(+0/-0); //NaNconsole.log(-0/-0); //NaN 如果分子是非0值，**分母是有符号0或无符号0**，则会返回 Infinity 或-Infinity。 1console.log(1/0); //Infinityconsole.log(1/-0); //-Infinityconsole.log(1/+0); //Infinity 任何涉及 NaN 的操作始终返回NaN 1console.log(NaN/10); //NaNconsole.log(1/10+NaN); //NaN console.log(1+(0/0)); //NaN NaN不等于包括NaN在内的任何值 1console.log(NaN==NaN); //falseconsole.log(NaN==(0/0)); //false ECMAScript提供isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否**不是数值。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10“或布尔值。任何不能转换为数值的值都会导致这个函数返回true。** 1console.log(isNaN(NaN)); //trueconsole.log(isNaN(&quot;Blue&quot;)); //trueconsole.log(isNaN(&quot;10&quot;)); //false 可转换为数值10 console.log(isNaN(true)); //false 可转换为数值 10console.log(isNaN(10)); //false 数值转换 3 个函数可以将非数值转换为数值 Number() Number()是转型函数，可用于任何数据类型 1let test1;let test2=null;const PI=3.14;let s=&quot;011&quot;;let s0=&quot;21&quot;;let s1=&quot;1.1&quot;;let s2=&quot;02.1&quot;;let s3=&quot;0xf&quot;;let s4=&quot;&quot;;let s5=&quot;s1&quot;;let s6=&quot;1.1d&quot;;console.log(Number(true)); //1console.log(Number(false)); //0console.log(Number(10)); //10console.log(Number(PI)); //3.14console.log(Number(test2)); //0console.log(Number(test1)); //NaNconsole.log(Number(s)); //11console.log(Number(s0)); //21console.log(Number(s1)); //1.1console.log(Number(s2)); //2.1console.log(Number(s3)); //15console.log(Number(s4)); //0console.log(Number(s5)); //NaNconsole.log(Number(s6)); //NaN parseInt() parseInt()函数可解析一个字符串，并返回一个整数。 通常需要得到整数时可优先使用**parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符**。 如果字符串以**0x开头，会被解释为十六进制整数。如果字符串以0开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数** 1let s=&quot;011&quot;;let s0=&quot;2.1&quot;;let s1=&quot;&quot;;let s2=&quot;blue1234&quot;;let s3=&quot;1234blue&quot;;let s4=&quot;12bl34ue&quot;;let s5=&quot;33.5blue&quot;;let s6=&quot;0xA&quot;;let s7=&quot;0xf&quot;;console.log(parseInt(s)); //11console.log(parseInt(s0)); //2console.log(parseInt(s1)); //NaNconsole.log(parseInt(s2)); //NaNconsole.log(parseInt(s3)); //1234console.log(parseInt(s4)); //12console.log(parseInt(s5)); //33console.log(parseInt(s6)); //10console.log(parseInt(s7)); //15 parseInt()可接收第二个参数，用于指定底数（进制数）。比如解析的值是十六进制，那么可以传入16 作为第二个参数。 1console.log(parseInt(&quot;0xAF&quot;,16)); //175console.log(parseInt(&quot;af&quot;,16)); //175 0x可省console.log(parseInt(&quot;AF&quot;)); //NaN 0x可省且不提供十六进制参数故检测到第一个字符是非数值字符后自动停止并返回NaNconsole.log(parseInt(&quot;10&quot;,2)); //2console.log(parseInt(&quot;10&quot;,8)); //8console.log(parseInt(&quot;10&quot;,10)); //10console.log(parseInt(&quot;10&quot;,16)); //16 不传底数参数相当于让parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数 parseFloat() parseFloat()函数是从位置0开始检测每个字符,解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这故第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。 parseFloat()函数始终忽略字符串开头的零。parseFloat()函数可识别浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。 parseFloat()只解析十进制值，不能指定底数。 如果字符串表示整数（没有小数点或者小数点后面只有一个零），则parseFloat()返回整数。 1console.log(parseFloat(&quot;1234blue&quot;)); //1234console.log(parseFloat(&quot;12.34&quot;)); //12.34console.log(parseFloat(&quot;012.34&quot;)); //12.34console.log(parseFloat(&quot;12.34.35&quot;)); //12.34console.log(parseFloat(&quot;12.0&quot;)); //12console.log(parseFloat(&quot;0xAF&quot;)); //0 ​ 5. String String（字符串）数据类型表示零或多个 16 位 Unicode字符序列。 字符串可以使用双引号（&quot;）、单引号（'）或反引号（``）标示,(ECMAScript`语法中表示字符串的引号没有区别。以某引号作为字符串开头，必须仍以该引号作为字符串结尾。 1let s1=&quot;test1&quot;;let s2='test2';let s3=`test3`;console.log(s1); //test1console.log(s2); //test2console.log(s3); //test3 字符字面量（表示非打印字符或有其他用途的字符） 1.可出现在字符串中任意位置，且可作为单个字符被解释; 字符串的长度可通过其 length 属性获取(如果字符串中包含双字节字符，那么length属性返回的值可能不是准确的字符数); 1console.log(&quot;\\ttest1&quot;); console.log(&quot;\\ttest2&quot;); console.log(&quot;test\\t&quot;); console.log(&quot;test&quot;); console.log(&quot;\\n&quot;); console.log(&quot;\\\\&quot;); console.log(&quot;\\'&quot;); console.log(&quot;\\&quot;&quot;); console.log(&quot;\\`&quot;); console.log(&quot;\\x41&quot;); console.log(&quot;\\u03a3&quot;); let text=&quot;HelloJavaScript&quot;; let text1=&quot;Hello JavaScript&quot;; let text2=&quot;Hello\\u03a3&quot;; let text3=&quot;Hello\\\\&quot;; console.log(text.length); //15 console.log(text1.length); //16 console.log(text2.length); //6 console.log(text3.length); //6 When to use special sequences \\b \\f and \\r in JavaScript - Stack Overflow ​ 字符串的特点 ECMAScript中的字符串是*不可变的（immutable）*，一旦创建，值就不能变*。要*修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量**。 1let text=&quot;Hello&quot;;console.log(text); //Hellotext=text+&quot;JavaScript&quot;;console.log(text); //HelloJavaScript//过程首先会分配一个足够容纳15个字符的空间，然后填充&quot;Hello&quot;和&quot;JavaScript&quot;。最后销毁原始的字符串&quot;Hello&quot;和字符串&quot;JavaScript&quot;。 转换为字符串 可使用几乎所有值都有的 **toString()方法。该方法唯一的用途是返回当前值的字符串等价物**。 如果不确定一个值是不是null或undefined，可使用**String()转型函数，它始终会返回表示相应类型值的字符串**。 toString() 可见于数值、布尔值、对象和字符串值。（字符串值使用toString()方法返回自身的一个副本)null 和 undefined 值没有 toString()方法 Uncaught TypeError: Cannot read property 'toString' of nul 1let age=10;let found=true;console.log(age.toString()); //10console.log(found.toString()); //true toString()不接收任何参数。不过，在对数值调用该方法时，toString()可接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，**toString()返回数值的十进制字符串表示。通过传入参数，可得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示。** 1let num=10;console.log(num.toString()); //10console.log(num.toString(2)); //1010console.log(num.toString(8)); //12console.log(num.toString(10)); //10console.log(num.toString(16)); //a String() String()转型函数始终会返回表示相应类型值的字符串。(如果不确定一个值是不是null或 undefined，可以使用 String()转型函数） 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。 如果值是 null，返回&quot;null&quot;。 如果值是 undefined，返回&quot;undefined&quot;。 1let v1=10;let v2=true;let v3;let v4=null;console.log(String(v1)); //10console.log(String(v1)===v1); //falseconsole.log(String(v1)===&quot;10&quot;);// trueconsole.log(String(v2)); //trueconsole.log(String(v3)); //undefinedconsole.log(String(v4)); //nullconsole.log(String(v4)==v4); //falseconsole.log(String(v4)===&quot;null&quot;); //true String()方法返回该值的字面量文本 加号操作符给一个值加上一个空字符串&quot;&quot;也可以将其转换为字符串 1let v4=null;console.log((v4+&quot;&quot;)===&quot;null&quot;); //true 模板字面量 模板字面量 ECMAScript 6 新增使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串。 1let myMultiLineString='hello world\\nJavaScript World';let myMultiLineTemplateLiteral=`hello worldJavaScript World`;let pageHtml =`&lt;div&gt; &lt;a href=&quot;#&quot;&gt; &lt;span&gt;Jake&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;`; //模板字面量定义模板console.log(myMultiLineString); //hello world //JavaScript Worldconsole.log(myMultiLineTemplateLiteral);//hello world //JavaScript Worldconsole.log(myMultiLineString==myMultiLineTemplateLiteral); //true 模板字面量会保持反引号内部的空格，空格的区别会导致二者不同console.log(pageHtml) 注意模板字面量会保持反引号内部的空格。 1let myTemplateLiteral = `my test hello JS`let myTemplateLiteral1 =`my testhello JS`let myTemplateLiteral2 = `my testhello JS`console.log(myTemplateLiteral);console.log(myTemplateLiteral1);console.log(myTemplateLiteral2);console.log(myTemplateLiteral.length);console.log(myTemplateLiteral1.length);console.log(myTemplateLiteral2.length);console.log(myTemplateLiteral1[0]=='\\n'); 字符串插值 模板字面量最常用的一个特性是**支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值**。 字符串插值通过在${}中使用一个JavaScript表达式实现 所有插入的值都会使用 toString()强制转型为字符串，任何 JavaScript 表达式都可以用于插值。 1let value = 5;let exponent = 'second';let interpolatedString = value + ' to the ' + exponent + ' power is ' + (value * value);let interpolatedTemplateLiteral = `${ value } to the ${ exponent } power is ${ value * value }`; console.log(interpolatedString); //5 to the second power is 25console.log(interpolatedTemplateLiteral); //5 to the second power is 25console.log(`The value is ${value}`); //The value is 5 将表达式转换为字符串时会调用 **toString()**。 1let foo = { toString: () =&gt; 'World' }; console.log(`Hello, ${ foo }!`); //Hello, World! 插值表达式中可以调用函数和方法 1function capitalize(word) { return `${ word[0].toUpperCase() }${ word.slice(1) }`; //toUpperCase()方法可将字符串转换为大写 //arrayObject.slice(start,end) 返回一个新数组，包含从start(必需)到end(可选。该参数是数组片断结束处的数组下标，不包括该元素。如果没有指定该参数，那么切分的数组包含从start到数组结束的所有元素)的arrayObject中的元素} console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World! 模板可插入之前的值 1let value = ''; function append() { value = `${value}abc` console.log(value); } append(); // abc append(); // abcabc append(); // abcabcabc 模板字面量标签函数 模板字面量支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。**标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。** 1let a = 6; let b = 9; function simpleTag(strings, aValExpression, bValExpression, sumExpression) { console.log(strings); console.log(aValExpression); console.log(bValExpression); console.log(sumExpression); return 'foobar'; }let untaggedResult = `${ a } + ${ b } = ${ a + b }`; let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`; // [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] // 6 // 9 // 15console.log(untaggedResult); // &quot;6 + 9 = 15&quot; console.log(taggedResult); // &quot;foobar&quot; ​ 对于有**n个插值的模板字面量，传给标签函数的表达式参数的个数始终是n**，而传给标签函数的第一个参数所包含的字符串个数则始终是 **n+1**。 1let a = 6; let b = 9; function zipTag(strings, ...expressions) { console.log(strings); return strings[0] + expressions.map((e, i) =&gt; `${e}${strings[i + 1]}`).join(''); } let untaggedResult = `${ a } + ${ b } = ${ a + b }`; let taggedResult = zipTag`${ a } + ${ b } = ${ a + b }`; console.log(untaggedResult); console.log(taggedResult); ​ 原始字符串 **使用模板字面量可直接获取原始的模板字面量内容（如换行符或 Unicode 字符）**。使用默认的 String.raw 标签函数。 1console.log('\\u00A9'); //©console.log(String.raw`\\u00A9`); //\\u00A9console.log('Hello\\nWorld'); //Hello//Worldconsole.log(String.raw`Hello\\nWorld`); //Hello\\nWorldconsole.log(`first line second line`); //first line //second line console.log(String.raw`first line second line`); //first line //second line 可通过标签函数的第一个参数，即字符串数组的.raw 属性取得每个字符串的原始内容 1function printRaw(strings){ for(const string of strings){ console.log(string); } for(const string of strings.raw){ console.log(string); } }printRaw`\\u00A9${ 'and' }\\n`;//©////\\u00A9//\\n 6. symbol Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。 符号基本用法 符号需要使用Symbol()函数初始化 1let sym = Symbol();console.log(typeof sym); //symbol 调用Symbol()函数时，可传入一个字符串参数作为对符号的描述（description），将来可通过该字符串调试代码。但该**字符串参数与符号定义或标识完全无关**。 1let genericSymbol = Symbol();let otherGenericSymbol = Symbol();let fooSymbol = Symbol('foo');let otherFooSymbol = Symbol('foo');console.log(genericSymbol==otherFooSymbol); //falseconsole.log(fooSymbol==otherFooSymbol); //false 符号没有字面量语法。只要创建 Symbol()实例并将其用作对象的新属性，就可保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。 1let genericSymbol = Symbol();console.log(genericSymbol); //Symbol()let fooSymbol = Symbol('foo');console.log(fooSymbol); //Symbol(foo) Symbol()函数不能与new关键字一起作为构造函数使用，避免创建符号包装对象。借用**Object()**函数可使用符号包装对象。 1let myBoolean = new Boolean(true);let yourBoolean = new Boolean();console.log(typeof myBoolean) //objectlet myString = new String();console.log(typeof myString); //objectlet myNumber = new Number();console.log(typeof myNumber); //objectlet mySymol = new Symbol(); //Uncaught TypeError: Symbol is not a constructorat new Symbol (&lt;anonymous&gt;)let mySymbol = Symbol();let myWrappedSymbol = Object(mySymbol);console.log(typeof myWrappedSymbol); //object 使用全局符号注册表 如果 运行时的不同部分需要共享和重用符号实例，那么可用一个字符串作为键，在全局符号注册表中创建并重用符号。 使用Symbol.for()方法 Symbol.for()对每个字符串键都执行幂等操作。 第一次使用某个字符串调用时，会检查全局运行时注册表，发现不存在对应的符号，于是会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。 1let fooGlobalSymbol = Symbol.for('foo'); //创建新符号console.log(typeof fooGlobalSymbol); //symbollet otherFooSymbol = Symbol.for('foo'); //重用已有符号console.log(fooGlobalSymbol=== otherFooSymbol); //true 即使采用相同的符号描述，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不等同。 1let globalSymbol = Symbol.for('foo'); let localSymbol = Symbol('foo');console.log(globalSymbol==localSymbol); //false 全局注册表中的符号必须使用字符串键来创建，因此作为参数传给Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。 1let globalSymbol = Symbol.for(); console.log(globalSymbol); //Symbol(undefined) Symbol.keyFor() 查询全局注册表，该方法接收符号并返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回 undefined。若传给**Symbol.keyFor()的不是符号，则该方法抛出TypeError**。 1let globalSymbol = Symbol.for(); let fooSymbol = Symbol.for('foo'); let localSymbol = Symbol('test');console.log(Symbol.keyFor(globalSymbol)); //undefinedconsole.log(Symbol.keyFor(localSymbol)); //undefinedconsole.log(Symbol.keyFor(fooSymbol)); //fooconsole.log(Symbol.keyFor(12)); //Uncaught TypeError: 12 is not a symbol 使用符号作为属性 凡是可以使用字符串或数值作为属性的地方，都可使用符号。这包括对象字面量属性和 Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。 1let s1 = Symbol('foo'), s2 = Symbol('bar'), s3 = Symbol('baz'), s4 = Symbol('qux');let ob1 = { [s1]:'foo val' //ob1[s1] = 'foo val';};console.log(ob1); //{Symbol(foo): foo val}Object.defineProperty(ob1,s2,{value: 'bar val'});console.log(ob1);//{Symbol(foo): foo val, Symbol(bar): bar val}Object.defineProperties(ob1,{ [s3]:{value: 'baz val'}, [s4]:{value: 'qux val'}});console.log(ob1);//{Symbol(foo): foo val, Symbol(bar): bar val, Symbol(baz): baz val, Symbol(qux): qux val} ​ ​ 类似于Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnProperty\u0002Symbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnProperty\u0002Descriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键。 1let s1 = Symbol('foo'); s2 = Symbol('bar');let ob2 = { [s1]: 'foo val', [s2]: 'bar val', baz: 'baz val', qux: 'qux val'};console.log(Object.getOwnPropertySymbols(ob2));//[Symbol(foo), Symbol(bar)] console.log(Object.getOwnPropertyNames(ob2));//[&quot;baz&quot;, &quot;qux&quot;]console.log(Object.getOwnPropertyDescriptors(ob2));//{baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}} console.log(Reflect.ownKeys(ob2))//[&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)] **符号属性是对内存中符号的一个引用，直接创建并用作属性的符号不会丢失。但如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键**。 1234567891011let ob = { [Symbol('foo')]: 'foo val', [Symbol('bar')]: 'bar val'};console.log(ob);///{Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;} let barSymbol = Object.getOwnPropertySymbols(ob).find((symbol) =&gt; symbol.toString().match(/bar/));console.log(barSymbol); //Symbol(bar) 常用内置符号 ECMAScript6引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。 这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。 Symbol.asyncIterator 该符号作为一个属性表示**一个方法，该方法返回对象默认的 AsyncIterator。由for-await-of语句使用。即这个符号表示实现异步迭代器API的函数。** 3.Node.js ​ Node.js","link":"/2021/08/14/JavaScript%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Aria2","slug":"Aria2","link":"/tags/Aria2/"},{"name":"Settings","slug":"Settings","link":"/tags/Settings/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"deploy","slug":"deploy","link":"/categories/deploy/"}]}